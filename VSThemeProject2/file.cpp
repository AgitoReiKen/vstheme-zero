
#include <stdio.h>
#define MACRO(x, y)
struct SynProstitutkiGalimoy;

typedef SynProstitutkiGalimoy You;
template<typename T, typename X = std::nullptr_t>
X Template(T* x) {
	return &x;
}

/*
* Comment
*/
static constexpr inline volatile const unsigned long long int& GlobalVariable = 0 + 1 / 2 * 5 % 6;

namespace Namespace  {
	class Derived {
	public:
		void Method() {}
		int Property;
	};
	MACRO(x, y);
	class Class : public Derived {
	 
	public:
		Class(...) {}
		Class(int NahuyPoshel, char Petuh) {}
		Class() {};
		static Function() {
		}
		MACRO(x, y);
		bool Load(int SomeVariable, Derived derived, ...) {
			int i1 = 1234567890;
			GlobalVariable;
			SomeVariable;
			// Comment
			i1;

			int i2 = 1234567890ul;
			int i3 = (int)'\001';
			auto* chars = "Chars\n";
			auto* chars = "12321";
			if (i != 0 || i == 1) {
				i++;
				i--; 
			}
			switch (i1) {
				case 0: {};
				case 1: {};
				default: {};
			}
			__interface IInterface
			{

			};
			typedef unsigned char BYTE;
			constexpr int x = (int)((BYTE)0x1Ell / (int)255);

			"\n";
			"Пошел \t\r\nнахуй \rлох \nххахаха))))))))))\r\n000000000000\n";
			"\001";
			this->Load()
			this->Method();
			this->Property;
		}
	}; 
}


Namespace::Class::Load(x);
int main(int x, char** args, ...)  {
	
	Namespace::Class::Function();
	x = x + 1;
	auto newClass = Namespace::Class();
	void* null = std::nullptr_t;
	auto __ = new char('\000');
	auto local = int(1);
	newClass.Load();
	(&newClass)->Load();
	((Namespace::Class*)((void*)(&newClass)))->Load();
	
	auto lambda = [=, this, &newClass]() -> bool {
		return true;
	}
	return false;
}